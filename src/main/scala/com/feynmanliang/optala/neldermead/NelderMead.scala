package com.feynmanliang.optala.neldermead

import breeze.linalg.{DenseVector, Vector, norm}
import com.feynmanliang.optala.{FunctionWithCounter, RunResult, Solution}

/** A `n+1` point simplex */
private[optala] case class Simplex(private val points: Seq[Solution]) {
  val solutionsByObj = points.sortBy(_.objVal) // simplex points sorted by increasing objective value
  val bestSolution = solutionsByObj.head // simplex point minimizing the objective function
  val centroid: DenseVector[Double] = solutionsByObj.map(_.point).reduce(_+_) / solutionsByObj.size.toDouble
  val averageObjVal: Double = solutionsByObj.map(_.objVal).sum / solutionsByObj.size.toDouble

  /** Ray from centroid of first n points to the n+1 point. */
  private[optala] def xBar(t: Double): DenseVector[Double] = {
    val nCentroid: DenseVector[Double] = {
      val n = solutionsByObj.size - 1D // number of points in simplex - 1
      solutionsByObj.init.map(_.point).reduce(_+_) / n
    }
    val xNplus1 = solutionsByObj.last.point
    nCentroid + t * (xNplus1 - nCentroid)
  }
}

/** Results from a run of Nelder-Mead. */
private[optala] case class NelderMeadRunResult(
    override val stateTrace: List[Simplex],
    override val numObjEval: Long,
    override val numGradEval: Long) extends RunResult[Simplex] {
  override val bestSolution = stateTrace.maxBy(_.bestSolution.objVal).bestSolution
}

/** An implementation of the Nelder-Mead optimization method.
  * @param maxObjEvals maximum number of objective function evaluations before termination
  * @param maxIter maximum number of iterations before termination
  * @param tol minimum change in norm between simplex centroids from two consecutive iterations before termination
  */
class NelderMead(
    var maxObjEvals: Int = Int.MaxValue,
    var maxIter: Int = 50000,
    var tol: Double = 1E-6) {

  /** Run Nelder-Mead starting with an initial simplex generated by uniformly sampling points from [-1,1]^d.
    * @param f objective function to be minimized
    * @param d dimensionality of the input domain of `f`
    * @param n number of simplex points
    */
  def minimize(
      f: Vector[Double] => Double,
      d: Int,
      n: Int): NelderMeadRunResult = {
    val init = Simplex(Seq.fill(n) {
      val x = 2D * (DenseVector.rand(d) - DenseVector.fill(d){0.5}) // randomly generate points in [-1,1]
      Solution(f, x)
    })
    minimize(f, init)
  }

  /** Run Nelder-Mead starting with a given initial simplex.
    * @param f objective function to be minimized
    * @param init initial simplex
    */
  def minimize(
      f: Vector[Double] => Double,
      init: Simplex): NelderMeadRunResult = {
    require(init.solutionsByObj.size >= 2, "must have at least 2 points in simplex")
    val fCnt = new FunctionWithCounter(f) // count the number of objective evaluations
    val xValues = nelderMead(fCnt, init)
      .takeWhile(_ => fCnt.numCalls <= maxObjEvals)
      .take(maxIter)
    val trace = xValues.head +: xValues
      .sliding(2)
      .takeWhile(x => norm(x(1).centroid - x.head.centroid) >= tol)
      .map(_(1))
      .toSeq
    NelderMeadRunResult(trace.toList, fCnt.numCalls, 0)
  }

  /** Construct a `Stream` (lazy sequence) of simplices updated according to Nelder-Mead iterations.
    * @param f objective function
    * @param simplex initial simplex
    */
  private def nelderMead(
      f: Vector[Double] => Double,
      simplex: Simplex): Stream[Simplex] = {
    val x1toN = simplex.solutionsByObj.init
    val x1 = simplex.solutionsByObj.head
    val xN = x1toN.last
    val xNplus1 = simplex.solutionsByObj.last
    val xRefl = Solution(f, simplex.xBar(-1D))

    if (x1.objVal <= xRefl.objVal && xRefl.objVal < xN.objVal) {
      // replace
      simplex #:: nelderMead(f, Simplex(x1toN :+ xRefl))
    } else if (xRefl.objVal < x1.objVal) {
      val xRefl2 = Solution(f, simplex.xBar(-2D)) // try an expansion (pattern move)
      if (xRefl2.objVal < xRefl.objVal) {
        // expand (pattern move)
        simplex #:: nelderMead(f, Simplex(x1toN :+ xRefl2))
      } else {
        // replace
        simplex #:: nelderMead(f, Simplex(x1toN :+ xRefl))
      }
    } else {
      // contract
      val xReflOut = Solution(f, simplex.xBar(-.5D))
      if (xN.objVal <= xRefl.objVal && xRefl.objVal < xNplus1.objVal && xReflOut.objVal <= xRefl.objVal) {
        // outside contraction
        simplex #:: nelderMead(f, Simplex(x1toN :+ xReflOut))
      } else{
        val xReflIn = Solution(f, simplex.xBar(.5D))
        if (xReflIn.objVal < xNplus1.objVal) {
          // inside contraction
          simplex #:: nelderMead(f, Simplex(x1toN :+ xReflIn))
        } else {
          // shrink
          simplex #:: nelderMead(f, Simplex(simplex.solutionsByObj.map { x =>
            val newX = .5D * (x1.point + x.point)
            Solution(f, newX)
          }))
        }
      }
    }
  }
}
